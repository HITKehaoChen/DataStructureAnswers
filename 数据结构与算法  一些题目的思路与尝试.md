# 数据结构与算法  一些题目的思路与尝试

## 第三章 树

------

P121.12

设一棵二叉树T，按图所给例子形式放在内存中，尝试给出一个算法，用来求T的高度，并对T的每一个结点赋予一个层号。

| Left | right | Level |
| ---- | ----- | ----- |
| 2    | 6     |       |
| 3    | 4     |       |
| 0    | 0     |       |
| 0    | 5     |       |
| 0    | 0     |       |
| 7    | 8     |       |
| 0    | 0     |       |
| 0    | 9     |       |
| 0    | 0     |       |

基本思路：

观察以上表格，我们会发现在这个二叉树中，存在许多叶结点。根据定义，树的高定义为根结点的高，即该棵树所有结点中最大的层号。而结点的层也就是从根到该结点的路长+1。

一个十分直观的想法是赋予层号，比较层号，取最大值为二叉树的高。

算法设计：



```c++
node[1].level = 1;
if(node->child != 0)
  node[node->child].level++;
//左右子结点同理。
height = max(node[i].level);
```



------

P121.13

试证明：任一棵高为h>1的二叉树，其内部结点(除根结点和叶结点之外的结点)的个数小于[2^(h-1)]-1,而叶结点的个数小于等于2^(h-1)





> 性质3.1 在二叉树中第i层的结点数最多为2^(i-1) (i>=1)

> 性质3.2 高度为k的二叉树其结点总数最多为2^k -1。

证明如下：

​	首先由性质3.1知，在二叉树第i层的结点数最多为2^(i-1) (i>=1)，显然，当且仅当二叉树为满二叉树(Full Binary Tree)时，其叶结点树达到最大值，为2^(i-1) (i>=1), 所以任一棵h>1的二叉树，其叶结点个数小于等于2^(h-1)。

​	同样，由性质3.1与性质3.2得知，

​		内部结点个数 < 2^h - 2^(h-1) -1 -1  = 2^(h-1) - 2  < 2^(h-1) - 1	

------

P121.14

​	题目太长，我懒得抄了。总之是一个带权二叉树的问题。





























































































